import csdl
import csdl_om
import numpy as np
from VLM_package.vlm_solver import VLMSolverModel
from VLM_package.examples.run_vlm.utils.generate_mesh import generate_mesh


class VLMAnalysis(csdl.Model):
    def initialize(self):
        self.parameters.declare('num_nodes')
        self.parameters.declare('v_inf_val')
        self.parameters.declare('aoa_val')
        self.parameters.declare('rho_val')
        self.parameters.declare('mesh')
        self.parameters.declare('nx')
        self.parameters.declare('ny')
        self.parameters.declare('offset')
        self.parameters.declare('surface_names')
        self.parameters.declare('surface_shapes')
        self.parameters.declare('model_name')

    def define(self):

        num_nodes = self.parameters['num_nodes']
        v_inf_val = self.parameters['v_inf_val']
        aoa_val = self.parameters['aoa_val']
        rho_val = self.parameters['rho_val']
        mesh = self.parameters['mesh']
        nx = self.parameters['nx']
        ny = self.parameters['ny']
        offset = self.parameters['offset']
        surface_names = self.parameters['surface_names']
        surface_shapes = self.parameters['surface_shapes']
        model_name = self.parameters['model_name']

        # ######################

        # mesh_val = generate_simple_mesh(nx, ny, num_nodes)
        mesh_val = np.zeros((num_nodes, nx, ny, 3))
        mesh_val_1 = np.zeros((num_nodes, nx, ny, 3))
        for i in range(num_nodes):
            mesh_val[i, :, :, :] = mesh
            mesh_val_1[i, :, :, :] = mesh.copy()
            mesh_val_1[i, :, :, 1] = mesh.copy()[:, :, 1] + offset

        # mesh_val_1 = generate_simple_mesh(nx, ny - 1,
        #                                   offset=offset).reshape(1, nx, ny - 1, 3)

        mesh_all = [mesh_val]
        ####################################################################
        # 2. Define rotational velocities
        # (naming conventions: name=surface_name+'_rot_vel' )
        # (you can skip this part if there is no rotation,
        # the rotational vel are defaulted to be zeros)
        ####################################################################

        rot_vel = self.create_input(model_name + surface_names[0] + '_rot_vel',
                                    val=np.zeros((num_nodes, nx, ny, 3)))

        wing = self.create_input(model_name + 'wing', val=mesh_val)
        wing_1 = self.create_input(model_name + 'wing_1', val=mesh_val_1)
        v_inf = self.create_input(model_name + 'v_inf', val=v_inf_val)
        aoa = self.create_input(model_name + 'aoa', val=aoa_val)
        rho = self.create_input(model_name + 'rho', val=rho_val)

        # aoa = model_1.create_input('aoa', val=np.array([10,10,10])
        # ##################################################################
        # 3. Define VLMSolverModel (using internal function)
        # The user needs to provide:
        #   surface_names(list),
        #   surface_shapes(list),
        #   free_stream_velocities(np.array, shape=(3,))
        #   eval_pts_location(float)
        #   eval_pts_shapes(list)
        # Here, the evaluation points are based on the relative
        # chordwise panel location generated by the vlm code internally
        # This is the default option
        # (eval_pts_location=0.25->evaluate the pressure at quarter-chord)
        # ###################################################################
        # The user can also define the eval_pts_coords inputs (line 97-146)
        # ###################################################################

        eval_pts_shapes = [(num_nodes, x[1] - 1, x[2] - 1, 3)
                           for x in surface_shapes]

        coeffs_aoa = [(0.535, 0.091), (0.535, 0.091)]
        coeffs_cd = [(0.00695, 1.297e-4, 1.466e-4),
                     (0.00695, 1.297e-4, 1.466e-4)]

        submodel = VLMSolverModel(
            surface_names=surface_names,
            surface_shapes=surface_shapes,
            num_nodes=num_nodes,
            # free_stream_velocities=free_stream_velocities,
            eval_pts_location=0.25,
            # The location of the evaluation point is on the quarter-chord,
            # if this is not provided, it is defaulted to be 0.25.
            eval_pts_shapes=eval_pts_shapes,
            model_name=model_name,
            coeffs_aoa=coeffs_aoa,
            coeffs_cd=coeffs_cd)

        self.add(submodel, 'VLMSolverModel')


class MultiPointRun(csdl.Model):
    def initialize(self):
        self.parameters.declare('surface_names')
        self.parameters.declare('points_dict')
        self.parameters.declare('num_nodes')

    def define(self):
        surface_names = self.parameters['surface_names']
        points_dict = self.parameters['points_dict']
        num_nodes = self.parameters['num_nodes']

        nx = 3  # streamwise vertices
        ny = 5  # chordwise vertices

        for span in [15.401544]:  #50.53 ft

            chord = 1.030224  # chord length 3.38ft
            surface_shapes = [(nx, ny, 3)]

            mesh_dict = {
                "num_y": ny,
                "num_x": nx,
                "wing_type": "rect",
                "symmetry": False,
                "span": span,
                "chord": chord,
                "span_cos_spacing": False,
                "chord_cos_spacing": False,
            }

            # Generate half-wing mesh of rectangular wing
        mesh = generate_mesh(mesh_dict)

        offset = 10

        # single lifting surface
        surface_shapes = [(num_nodes, nx, ny, 3), (num_nodes, nx, ny, 3)]

        ######################
        # v_inf degree
        # rho
        # aoa
        ######################

        # Loop through each point given as a parameter.
        store_lift = []
        for point in points_dict:
            # model name = name of the point, so cruise, climb etc
            model_name = point + '_'

            # inputs
            v_inf_val = points_dict[point]['v_inf_val']
            aoa_val = points_dict[point]['aoa_val']
            rho_val = points_dict[point]['rho_val']

            surface_names_model = []
            for sn in surface_names:
                surface_names_model.append(model_name + sn)

            # add a VLMAnalysis for each point
            self.add(
                VLMAnalysis(
                    num_nodes=num_nodes,
                    v_inf_val=v_inf_val,
                    mesh=mesh,
                    nx=nx,
                    ny=ny,
                    offset=offset,
                    surface_names=surface_names_model,
                    surface_shapes=surface_shapes,
                    model_name=
                    model_name,  # Every name in the VLMAnalysis model has model_name as a prefix. Needed for UQ graph analysis.
                    aoa_val=aoa_val,
                    rho_val=rho_val,
                ),
                name=point)

            # lift as output
            L_name = surface_names_model[0] + '_L_panel'
            l_var = self.declare_variable(L_name, shape=(num_nodes, 8, 1))
            store_lift.append(l_var)

        # Simple sum of lifts
        self.register_output('lift_sum', store_lift[0] + store_lift[1])


# surface names
surface_names = ['wing', 'wing_1']
# dictionary containing parameters for each point
# density: # https://www.engineeringtoolbox.com/standard-atmosphere-d_604.html

# =============== Setting Points ===============
points_dict = {}
num_nodes = 3

# climb:
# density 8kft --> 18.728 e-4 sl/ft3 --> 0.9652kg/m^3
# aoa --> 20deg
# v --> 0.3Ma --> 102.9m/s
points_dict['climb'] = {
    'v_inf_val': np.array([92.9, 102.9, 112.9]).reshape(-1, 1),
    'aoa_val': np.array([20, 20, 20]).reshape(-1, 1),
    'rho_val': np.array([0.9652, 0.9652, 0.9652]).reshape(-1, 1)
}

# cruise:
# density 10kft --> 17.56e-4 sl/ft3 --> 0.905kg/m^3
# aoa --> 0deg
# v --> 0.5Ma --> 171.5m/s
points_dict['cruise'] = {
    'v_inf_val': np.array([161.5, 171.5, 181.5]).reshape(-1, 1),
    'aoa_val': np.array([0.0, 0.0, 0.0]).reshape(-1, 1),
    'rho_val': np.array([0.905, 0.905, 0.905]).reshape(-1, 1)
}
rv_list = ['climb_v_inf', 'cruise_v_inf']
# =============== Setting Points ===============

model = MultiPointRun(surface_names=surface_names,
                      points_dict=points_dict,
                      num_nodes=num_nodes)

# set to 1 is applying uq reduction
if 0:
    from apply_uq import apply_uq
    apply_uq(model, 3, rv_list)

# simulator
sim = csdl_om.Simulator(model)
# sim.visualize_implementation()
sim.run()

# print outputs
for point in points_dict:
    surface_names_point = []
    for sn in surface_names:
        surface_names_point.append(point + '_' + sn)
    for i in range(len(surface_names)):

        L_panel_name = surface_names_point[i] + '_L_panel'
        D_panel_name = surface_names_point[i] + '_D_panel'
        L_name = surface_names_point[i] + '_L'
        D_name = surface_names_point[i] + '_D'
        D_total_name = surface_names_point[i] + '_D_total'
        CL_name = surface_names_point[i] + '_C_L'
        CD_name = surface_names_point[i] + '_C_D_i'
        print(point, 'lift\n', L_name, sim.prob[L_name])
        print(point, 'drag excluding viscous drag\n', D_name, sim.prob[D_name])
        print(point, 'total drag\n', D_total_name, sim.prob[D_total_name])
        print(point, 'cl\n', CL_name, sim.prob[CL_name])
        print(point, 'cd\n', CD_name, sim.prob[CD_name])

print('lift_sum:', sim.prob['lift_sum'])
print('lift_sum shape:', sim.prob['lift_sum'].shape)
