import csdl
import csdl_om
import numpy as np
from VLM_package.vlm_solver import VLMSolverModel
from VLM_package.examples.run_vlm.utils.generate_mesh import generate_mesh


class VLMAnalysis(csdl.Model):

    def initialize(self):
        self.parameters.declare('num_nodes')
        self.parameters.declare('v_inf_val')
        self.parameters.declare('mesh')
        self.parameters.declare('nx')
        self.parameters.declare('ny')
        self.parameters.declare('offset')
        self.parameters.declare('surface_names')
        self.parameters.declare('surface_shapes')
        self.parameters.declare('model_name')

    def define(self):

        num_nodes = self.parameters['num_nodes']
        v_inf_val = self.parameters['v_inf_val']
        mesh = self.parameters['mesh']
        nx = self.parameters['nx']
        ny = self.parameters['ny']
        offset = self.parameters['offset']
        surface_names = self.parameters['surface_names']
        surface_shapes = self.parameters['surface_shapes']
        model_name = self.parameters['model_name']
        # ######################

        aoa_val = np.array([2, 4, 6]).reshape(-1, 1)

        # mesh_val = generate_simple_mesh(nx, ny, num_nodes)
        mesh_val = np.zeros((num_nodes, nx, ny, 3))
        mesh_val_1 = np.zeros((num_nodes, nx, ny, 3))
        for i in range(num_nodes):
            mesh_val[i, :, :, :] = mesh
            mesh_val_1[i, :, :, :] = mesh.copy()
            mesh_val_1[i, :, :, 1] = mesh.copy()[:, :, 1] + offset

        # mesh_val_1 = generate_simple_mesh(nx, ny - 1,
        #                                   offset=offset).reshape(1, nx, ny - 1, 3)

        mesh_all = [mesh_val]
        ####################################################################
        # 2. Define rotational velocities
        # (naming conventions: name=surface_name+'_rot_vel' )
        # (you can skip this part if there is no rotation,
        # the rotational vel are defaulted to be zeros)
        ####################################################################

        rot_vel = self.create_input(surface_names[0] + '_rot_vel',
                                    val=np.zeros((num_nodes, nx, ny, 3)))

        wing = self.create_input('wing', val=mesh_val)
        wing_1 = self.create_input('wing_1', val=mesh_val_1)
        v_inf = self.create_input('v_inf', val=v_inf_val)
        aoa = self.create_input('aoa', val=aoa_val)

        # rho = model_1.create_input('rho', val=np.array([0.38,0.38,0.38])
        # aoa = model_1.create_input('aoa', val=np.array([10,10,10])
        # ##################################################################
        # 3. Define VLMSolverModel (using internal function)
        # The user needs to provide:
        #   surface_names(list),
        #   surface_shapes(list),
        #   free_stream_velocities(np.array, shape=(3,))
        #   eval_pts_location(float)
        #   eval_pts_shapes(list)
        # Here, the evaluation points are based on the relative
        # chordwise panel location generated by the vlm code internally
        # This is the default option
        # (eval_pts_location=0.25->evaluate the pressure at quarter-chord)
        # ###################################################################
        # The user can also define the eval_pts_coords inputs (line 97-146)
        # ###################################################################

        eval_pts_shapes = [(num_nodes, x[1] - 1, x[2] - 1, 3) for x in surface_shapes]

        submodel = VLMSolverModel(
            surface_names=surface_names,
            surface_shapes=surface_shapes,
            num_nodes=num_nodes,
            # free_stream_velocities=free_stream_velocities,
            eval_pts_location=0.25,
            # The location of the evaluation point is on the quarter-chord,
            # if this is not provided, it is defaulted to be 0.25.
            eval_pts_shapes=eval_pts_shapes,
            model_name = '',
        )

        self.add(submodel, 'VLMSolverModel')


class MultiPointRun(csdl.Model):

    def initialize(self):
        self.parameters.declare('surface_names')
        self.parameters.declare('points_dict')

    def define(self):
        surface_names = self.parameters['surface_names']
        points_dict = self.parameters['points_dict']

        nx = 3  # streamwise vertices
        ny = 5  # chordwise vertices

        for span in [6]:

            chord = 1  # chord length
            surface_shapes = [(nx, ny, 3)]

            mesh_dict = {
                "num_y": ny,
                "num_x": nx,
                "wing_type": "rect",
                "symmetry": False,
                "span": span,
                "chord": chord,
                "span_cos_spacing": False,
                "chord_cos_spacing": False,
            }

            # Generate half-wing mesh of rectangular wing
        mesh = generate_mesh(mesh_dict)

        num_nodes = 3
        offset = 10

        # single lifting surface
        surface_shapes = [(num_nodes, nx, ny, 3), (num_nodes, nx, ny, 3)]

        ######################
        # v_inf degree
        # rho
        # aoa
        ######################

        # Loop through given as a parameter.
        for point in points_dict:
            model_name = point
            v_inf_val = points_dict[point]['v_inf_val']

            self.add(VLMAnalysis(
                num_nodes=num_nodes,
                v_inf_val=v_inf_val,
                mesh=mesh,
                nx=nx,
                ny=ny,
                offset=offset,
                surface_names=surface_names,
                surface_shapes=surface_shapes,
                model_name='',
            ), name=model_name, promotes=[])

        # ADD SOMETHING HERE TO COMBINE RESULTS FROM EACH POINT


# surface names
surface_names = ['wing', 'wing_1']

# dictionary containing parameters for each point
points_dict = {}
points_dict['cruise'] = {'v_inf_val': np.array([50, 60, 70]).reshape(-1, 1)}
points_dict['hover'] = {'v_inf_val': np.array([55, 65, 75]).reshape(-1, 1)}

# simulator
sim = csdl_om.Simulator(MultiPointRun(surface_names=surface_names, points_dict=points_dict))
sim.run()


for point in points_dict:
    for i in range(len(surface_names)):

        L_panel_name = point + '.' + surface_names[i] + '_L_panel'
        D_panel_name = point + '.' + surface_names[i] + '_D_panel'
        L_name = point + '.' + surface_names[i] + '_L'
        D_name = point + '.' + surface_names[i] + '_D'
        CL_name = point + '.' + surface_names[i] + '_C_L'
        CD_name = point + '.' + surface_names[i] + '_C_D_i'
        print(point, 'lift\n', L_name, sim.prob[L_name])
        print(point, 'drag\n', D_name, sim.prob[D_name])
        # print(
        #     'L_panel',
        #     L_panel_name,
        #     sim.prob[L_panel_name].shape,
        #     sim.prob[L_panel_name],
        # )
        # print(
        #     'D_panel',
        #     D_panel_name,
        #     sim.prob[D_panel_name].shape,
        #     sim.prob[D_panel_name],
        # )
        print(point, 'cl\n', CL_name, sim.prob[CL_name])
        print(point, 'cd\n', CD_name, sim.prob[CD_name])
# cruise lift
#  cruise.wing_L [[1257.80723336]
#  [3619.59144134]
#  [7380.17296159]]
# cruise drag
#  cruise.wing_D [[  8.42577224]
#  [ 48.45433751]
#  [147.99356276]]
# cruise cl
#  cruise.wing_C_L [[0.16770763]
#  [0.33514736]
#  [0.50205258]]
# cruise cd
#  cruise.wing_C_D_i [[0.00112344]
#  [0.00448651]
#  [0.01006759]]
# cruise lift
#  cruise.wing_1_L [[1257.80723336]
#  [3619.59144134]
#  [7380.17296159]]
# cruise drag
#  cruise.wing_1_D [[  8.42577224]
#  [ 48.45433751]
#  [147.99356276]]
# cruise cl
#  cruise.wing_1_C_L [[0.16770763]
#  [0.33514736]
#  [0.50205258]]
# cruise cd
#  cruise.wing_1_C_D_i [[0.00112344]
#  [0.00448651]
#  [0.01006759]]
# hover lift
#  hover.wing_L [[1521.94676448]
#  [4247.99275321]
#  [8472.13735376]]
# hover drag
#  hover.wing_D [[ 10.19518415]
#  [ 56.86654802]
#  [169.89056784]]
# hover cl
#  hover.wing_C_L [[0.16770763]
#  [0.33514736]
#  [0.50205258]]
# hover cd
#  hover.wing_C_D_i [[0.00112344]
#  [0.00448651]
#  [0.01006759]]
# hover lift
#  hover.wing_1_L [[1521.94676448]
#  [4247.99275321]
#  [8472.13735376]]
# hover drag
#  hover.wing_1_D [[ 10.19518415]
#  [ 56.86654802]
#  [169.89056784]]
# hover cl
#  hover.wing_1_C_L [[0.16770763]
#  [0.33514736]
#  [0.50205258]]
# hover cd
#  hover.wing_1_C_D_i [[0.00112344]
#  [0.00448651]
#  [0.01006759]]