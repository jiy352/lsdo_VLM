import numpy as np
from scipy.sparse import coo_array

from VLM_package.VLM_preprocessing.generate_simple_mesh import *

from VLM_package.vlm_solver import VLMSolverModel
'''
This example demonstrates the basic VLM simulation 
with a single lifting surface with internal function to generate evaluation pts
Please see vlm_scipt_mls.py for how to use user defined evaluation pts
'''

####################################################################
# 1. Define VLM meshes and constants
####################################################################
nx = 3
ny = 10
offset = 10

v_inf = 50
alpha_deg = 10
alpha = alpha_deg / 180 * np.pi
vx = -v_inf * np.cos(alpha)
vz = -v_inf * np.sin(alpha)
free_stream_velocities = np.array([-vx, 0, -vz])
frame_vel_val = np.array([vx, 0, vz])

# single lifting surface
surface_names = ['wing']
surface_shapes = [(nx, ny, 3)]

model_1 = csdl.Model()

mesh_val = generate_simple_mesh(nx, ny).reshape(1, nx, ny, 3)
# mesh_val_1 = generate_simple_mesh(nx, ny - 1,
#                                   offset=offset).reshape(1, nx, ny - 1, 3)

mesh_all = [mesh_val]
####################################################################
# 2. Define rotational velocities
# (naming conventions: name=surface_name+'_rot_vel' )
# (you can skip this part if there is no rotation,
# the rotational vel are defaulted to be zeros)
####################################################################

rot_vel = model_1.create_input(surface_names[0] + '_rot_vel',
                               val=np.zeros((nx, ny, 3)))

wing = model_1.create_input('wing', val=mesh_val)

# ##################################################################
# 3. Define VLMSolverModel (using internal function)
# The user needs to provide:
#   surface_names(list),
#   surface_shapes(list),
#   free_stream_velocities(np.array, shape=(3,))
#   eval_pts_location(float)
#   eval_pts_shapes(list)
# Here, the evaluation points are based on the relative
# chordwise panel location generated by the vlm code internally
# This is the default option
# (eval_pts_location=0.25->evaluate the pressure at quarter-chord)
# ###################################################################
# The user can also define the eval_pts_coords inputs (line 97-146)
# ###################################################################

eval_pts_shapes = [(x[0] - 1, x[1] - 1, 3) for x in surface_shapes]

submodel = VLMSolverModel(
    surface_names=surface_names,
    surface_shapes=surface_shapes,
    free_stream_velocities=free_stream_velocities,
    eval_pts_location=0.25,
    # The location of the evaluation point is on the quarter-chord,
    # if this is not provided, it is defaulted to be 0.25.
    eval_pts_shapes=eval_pts_shapes,
)

model_1.add(submodel, 'VLMSolverModel')

sim = Simulator(model_1)

sim.run()

####################################################################
# Print VLM outputs
####################################################################

for i in range(len(surface_names)):

    L_panel_name = surface_names[i] + '_L_panel'
    D_panel_name = surface_names[i] + '_D_panel'
    L_name = surface_names[i] + '_L'
    D_name = surface_names[i] + '_D'
    CL_name = surface_names[i] + '_C_L'
    CD_name = surface_names[i] + '_C_D_i'
    print('lift', L_name, sim.prob[L_name])
    print('drag', D_name, sim.prob[D_name])
    print(
        'L_panel',
        L_panel_name,
        sim.prob[L_panel_name].shape,
        sim.prob[L_panel_name],
    )
    print(
        'D_panel',
        D_panel_name,
        sim.prob[D_panel_name].shape,
        sim.prob[D_panel_name],
    )
    print('cl', CL_name, sim.prob[CL_name])
    print('cd', CD_name, sim.prob[CD_name])
####################################################################
# Visualize n2 diagram (line 188)
####################################################################

# sim.visualize_implementation()
