import numpy as np
from scipy.sparse import coo_array

from VLM_package.VLM_preprocessing.generate_simple_mesh import *

from VLM_package.vlm_solver import VLMSolverModel

####################################################################
# 1. Define VLM meshes and constants
####################################################################
nx = 3
ny = 10
offset = 12

v_inf = 50
alpha_deg = 10
alpha = alpha_deg / 180 * np.pi
vx = -v_inf * np.cos(alpha)
vz = -v_inf * np.sin(alpha)
free_stream_velocities = np.array([-vx, 0, -vz])
frame_vel_val = np.array([vx, 0, vz])

# multiple lifting surface
surface_names = ['wing', 'wing_1']
surface_shapes = [(nx, ny, 3), (nx, ny, 3)]

# single lifting surface
# surface_names = ['wing']
# surface_shapes = [(nx, ny, 3)]

model_1 = csdl.Model()

mesh_val = generate_simple_mesh(nx, ny).reshape(1, nx, ny, 3)
# mesh_val_1_temp = generate_simple_mesh(nx, ny,
#                                        offset=offset).reshape(nx, ny, 3)
# mesh_val_1 = np.flip(mesh_val_1_temp, 1).reshape(1, nx, ny, 3)

mesh_val_1 = generate_simple_mesh(nx, ny, offset=offset).reshape(1, nx, ny, 3)
from mpl_toolkits.mplot3d import axes3d
import matplotlib.pyplot as plt

fig = plt.figure()
ax = fig.add_subplot(projection='3d')

X, Y_1, Z = mesh_val[:, :, :, 0].reshape(nx, ny), mesh_val[:, :, :, 1].reshape(
    nx, ny), mesh_val[:, :, :, 2].reshape(nx, ny)
# Plot a basic wireframe.
ax.plot_wireframe(X, Y_1, Z)

X, Y_2, Z = mesh_val_1[:, :, :,
                       0].reshape(nx, ny), mesh_val_1[:, :, :, 1].reshape(
                           nx, ny), mesh_val_1[:, :, :, 2].reshape(nx, ny)
max_range = np.array(
    [X.max() - X.min(),
     Y_2.max() - Y_1.min(),
     Z.max() - Z.min()]).max() / 2.0

mid_x = (X.max() + X.min()) * 0.5
mid_y = (Y_2.max() + Y_1.min()) * 0.5
mid_z = (Z.max() + Z.min()) * 0.5
ax.set_xlim(mid_x - max_range, mid_x + max_range)
ax.set_ylim(mid_y - max_range, mid_y + max_range)
ax.set_zlim(mid_z - max_range, mid_z + max_range)

# Plot a basic wireframe.
ax.plot_wireframe(X, Y_2, Z)
plt.show()
mesh_all = [mesh_val, mesh_val_1]
####################################################################
# 2. Define rotational velocities
# (naming conventions: name=surface_name+'_rot_vel' )
# (you can skip this part if there is no rotation,
# the rotational vel are defaulted to be zeros)
####################################################################

rot_vel = model_1.create_input(surface_names[0] + '_rot_vel',
                               val=np.zeros((nx, ny, 3)))
rot_vel_1 = model_1.create_input(surface_names[1] + '_rot_vel',
                                 val=np.zeros((nx, ny, 3)))

wing = model_1.create_input('wing', val=mesh_val)
wing_1 = model_1.create_input('wing_1', val=mesh_val_1)

# ##################################################################
# 3. Define VLMSolverModel (using internal function)
# The user needs to provide:
#   surface_names(list),
#   surface_shapes(list),
#   free_stream_velocities(np.array, shape=(3,))
#   eval_pts_location(float)
#   eval_pts_shapes(list)
# Here, the evaluation points are based on the relative
# chordwise panel location generated by the vlm code internally
# This is the default option
# (eval_pts_location=0.25->evaluate the pressure at quarter-chord)
# ###################################################################
# The user can also define the eval_pts_coords inputs (line 97-146)
# ###################################################################

eval_pts_shapes = [(x[0] - 1, x[1] - 1, 3) for x in surface_shapes]

submodel = VLMSolverModel(
    surface_names=surface_names,
    surface_shapes=surface_shapes,
    free_stream_velocities=free_stream_velocities,
    eval_pts_location=0.25,
    # The location of the evaluation point is on the quarter-chord,
    # if this is not provided, it is defaulted to be 0.25.
    eval_pts_shapes=eval_pts_shapes,
)

# ####################################################################
# 3. Define VLMSolverModel (user-defined eval_pts)
# # This example demos how to provide
# # user-defined eval_pts_coords as a csdl variable
# ####################################################################
'''
e.g., center of leading edge panels
. - . - . - .
| * |   |   |
. - . - . - .
| * |   |   |
. - . - . - .
| * |   |   |
. - . - . - .
'''
# eval_pts_option = 'user_defined'
# eval_pts_names = [x + '_eval_pts_coords' for x in surface_names]

# eval_pts_shapes = [(1, ny , 3),
#                    (1, ny , 3)]  # center of leading edge panels
# sprs = [1] * len(eval_pts_shapes)
# for i in range(len(eval_pts_names)):

#     surface_shape = surface_shapes[i]
#     mesh_current = mesh_all[i]
#     n_chord_panel = surface_shape[0] - 1
#     n_span_panel = surface_shape[1] - 1

#     eval_pts_location = 0.5

#     all_center_pts = (
#         (1 - eval_pts_location) * 0.5 * mesh_current[:, 0:-1, 0:-1, :] +
#         (1 - eval_pts_location) * 0.5 * mesh_current[:, 0:-1, 1:, :] +
#         eval_pts_location * 0.5 * mesh_current[:, 1:, 0:-1, :] +
#         eval_pts_location * 0.5 * mesh_current[:, 1:, 1:, :])

#     eval_pts_coords = all_center_pts[:,
#                                      0, :, :]  # center of leading edge panels (nx = 0)
#     if eval_pts_option == 'user_defined':
#         eval_pts = model_1.create_input(eval_pts_names[i],
#                                         val=eval_pts_coords.reshape(
#                                             eval_pts_shapes[i]))

#         row = np.arange(n_span_panel)
#         col = np.arange(n_span_panel)
#         data = np.ones(n_span_panel)
#         sprs[i] = coo_array(
#             (data, (row, col)),
#             shape=(n_span_panel, n_chord_panel * n_span_panel),
#         )

#         #here we need to define a sparse matrix, such that
#         # sprs@vector = the ones that we selected
#         # shapes: (num_evel_pts, num_total_circualtion_strength)
#         # num_total_circualtion_strength=(nx-1)*(ny-1)

# submodel = VLMSolverModel(
#     surface_names=surface_names,
#     surface_shapes=surface_shapes,
#     free_stream_velocities=free_stream_velocities,
#     eval_pts_location=0.25,
#     eval_pts_option=eval_pts_option,
#     eval_pts_shapes=eval_pts_shapes,
#     sprs=sprs,
# )

#############################################################
model_1.add(submodel, 'VLMSolverModel')

sim = Simulator(model_1)

sim.run()

####################################################################
# Print VLM outputs
####################################################################

for i in range(len(surface_names)):

    L_panel_name = surface_names[i] + '_L_panel'
    D_panel_name = surface_names[i] + '_D_panel'
    L_name = surface_names[i] + '_L'
    D_name = surface_names[i] + '_D'
    CL_name = surface_names[i] + '_C_L'
    CD_name = surface_names[i] + '_C_D_i'
    print('lift', L_name, '\n', sim.prob[L_name])
    print('drag', D_name, '\n', sim.prob[D_name])
    print(
        'L_panel',
        L_panel_name,
        '\n',
        sim.prob[L_panel_name].shape,
        sim.prob[L_panel_name],
    )
    print(
        'D_panel',
        D_panel_name,
        '\n',
        sim.prob[D_panel_name].shape,
        sim.prob[D_panel_name],
    )
    print('cl', CL_name, '\n', sim.prob[CL_name])
    print('cd', CD_name, '\n', sim.prob[CD_name])
####################################################################
# Visualize n2 diagram (line 188)
####################################################################

# sim.visualize_implementation()

######################### END of CODE ###########################################

# eval_pts_option = 'user_defined'
# eval_pts_names = [x + '_eval_pts_coords' for x in surface_names]

# eval_pts_shapes = [(nx - 1, ny - 1, 3),
#                    (nx - 1, ny - 2, 3)]  # center of leading edge panels
# sprs = [1] * len(eval_pts_shapes)
# for i in range(len(eval_pts_names)):

#     surface_shape = surface_shapes[i]
#     mesh_current = mesh_all[i]
#     n_chord_panel = surface_shape[0] - 1
#     n_span_panel = surface_shape[1] - 1

#     eval_pts_location = 0.25

#     all_center_pts = (
#         (1 - eval_pts_location) * 0.5 * mesh_current[:, 0:-1, 0:-1, :] +
#         (1 - eval_pts_location) * 0.5 * mesh_current[:, 0:-1, 1:, :] +
#         eval_pts_location * 0.5 * mesh_current[:, 1:, 0:-1, :] +
#         eval_pts_location * 0.5 * mesh_current[:, 1:, 1:, :])

#     eval_pts_coords = all_center_pts  # center of leading edge panels (nx = 0)
#     if eval_pts_option == 'user_defined':
#         eval_pts = model_1.create_input(eval_pts_names[i],
#                                         val=eval_pts_coords.reshape(
#                                             eval_pts_shapes[i]))

#         row = np.arange(n_chord_panel * n_span_panel)
#         col = np.arange(n_chord_panel * n_span_panel)
#         data = np.ones(n_chord_panel * n_span_panel)
#         sprs[i] = coo_array(
#             (data, (row, col)),
#             shape=(n_chord_panel * n_span_panel, n_chord_panel * n_span_panel),
#         )

#         #here we need to define a sparse matrix, such that
#         # sprs@vector = the ones that we selected
#         # shapes: (num_evel_pts, num_total_circualtion_strength)
#         # num_total_circualtion_strength=(nx-1)*(ny-1)

# submodel = VLMSolverModel(
#     surface_names=surface_names,
#     surface_shapes=surface_shapes,
#     free_stream_velocities=free_stream_velocities,
#     eval_pts_location=0.25,
#     eval_pts_option=eval_pts_option,
#     eval_pts_shapes=eval_pts_shapes,
#     sprs=sprs,
# )