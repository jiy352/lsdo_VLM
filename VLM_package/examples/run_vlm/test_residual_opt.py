from math import gamma
import numpy as np

from VLM_package.VLM_preprocessing.utils.generate_simple_mesh import *

from VLM_package.vlm_solver import VLMSolverModel

from VLM_package.examples.run_vlm.utils.generate_mesh import generate_mesh

from VLM_package.VLM_preprocessing.geometry.generate_mesh_given_twist import Rotate
from VLM_package.VLM_preprocessing.geometry.generate_spline import BSpline

import csdl_lite

import openmdao.api as om
'''
This example demonstrates the basic VLM simulation 
with a single lifting surface with internal function to generate evaluation pts
Please see vlm_scipt_mls.py for how to use user defined evaluation pts
'''

####################################################################
# 1. Define VLM meshes and constants
####################################################################

for span in [15.401544]:

    nx = 3
    ny = 5
    chord = 1.030224
    surface_shapes = [(nx, ny, 3)]

    mesh_dict = {
        "num_y": ny,
        "num_x": nx,
        "wing_type": "rect",
        "symmetry": False,
        "span": span,
        "chord": chord,
        "span_cos_spacing": False,
        "chord_cos_spacing": False,
    }

    # Generate half-wing mesh of rectangular wing
mesh = generate_mesh(mesh_dict)

num_nodes = 1
nx = 3
ny = 5
offset = 10

# v_inf = np.array([50, 50, 50])
# alpha_deg = np.array([2, 4, 6])
# beta_deg = np.array([0, 4, 6])
# alpha = alpha_deg / 180 * np.pi
# beta = beta_deg / 180 * np.pi

# vx = -v_inf * np.cos(alpha) * np.cos(beta)
# vy = v_inf * np.sin(beta)
# vz = -v_inf * np.sin(alpha) * np.cos(beta)

# vx = np.ones(num_nodes, ) * 3
# vy = np.zeros(num_nodes, )
# vz = np.ones(num_nodes, )
# v_inf = np.sqrt(vx**2 + vz**2)

aoa = 5
side_slip_ang = 0
alpha = aoa / 180 * np.pi
v_inf = np.array([87.0856319])

beta = side_slip_ang / 180 * np.pi
vx = -v_inf * np.cos(alpha) * np.cos(beta)
vy = v_inf * np.sin(beta)
vz = -v_inf * np.sin(alpha) * np.cos(beta)

free_stream_velocities = np.array([-vx, -vy, -vz]).T
frame_vel_val = np.array([vx, vy, vz]).T

# single lifting surface
surface_names = ['wing']
surface_shapes = [(num_nodes, nx, ny, 3)]

model_1 = csdl.Model()

# mesh_val = generate_simple_mesh(nx, ny, num_nodes)
mesh_val = np.zeros((num_nodes, nx, ny, 3))
for i in range(num_nodes):
    mesh_val[i, :, :, :] = mesh

# mesh_val_1 = generate_simple_mesh(nx, ny - 1,
#                                   offset=offset).reshape(1, nx, ny - 1, 3)

mesh_all = [mesh_val]
gamma_b = model_1.create_input('gamma_b',
                               val=np.zeros((num_nodes, (nx - 1) * (ny - 1))))
####################################################################
# 2. Define rotational velocities
# (naming conventions: name=surface_name+'_rot_vel' )
# (you can skip this part if there is no rotation,
# the rotational vel are defaulted to be zeros)
####################################################################

rot_vel = model_1.create_input(surface_names[0] + '_rot_vel',
                               val=np.zeros((num_nodes, nx, ny, 3)))
twist_cp = model_1.create_input('twist_cp', val=np.random.random(3))
spline = csdl.custom(twist_cp, op=BSpline(ny=ny))
model_1.register_output('twist', spline)

in_mesh = model_1.create_input('in_mesh', val=mesh)
twist = model_1.declare_variable('twist', val=np.random.random(ny))
twisted_mesh = csdl.custom(twist,
                           in_mesh,
                           op=Rotate(val=np.zeros(ny),
                                     mesh_shape=mesh.shape,
                                     symmetry=False))
model_1.register_output('mesh', twisted_mesh)
final_mesh = csdl.expand(twisted_mesh, (num_nodes, nx, ny, 3), 'jkl->ijkl')

model_1.register_output(surface_names[0], final_mesh)

# wing = model_1.create_input('wing', val=mesh_val)
v_inf = model_1.create_input('v_inf', val=v_inf.reshape(-1, 1))
# ##################################################################
# 3. Define VLMSolverModel (using internal function)
# The user needs to provide:
#   surface_names(list),
#   surface_shapes(list),
#   free_stream_velocities(np.array, shape=(3,))
#   eval_pts_location(float)
#   eval_pts_shapes(list)
# Here, the evaluation points are based on the relative
# chordwise panel location generated by the vlm code internally
# This is the default option
# (eval_pts_location=0.25->evaluate the pressure at quarter-chord)
# ###################################################################
# The user can also define the eval_pts_coords inputs (line 97-146)
# ###################################################################

eval_pts_shapes = [(num_nodes, x[1] - 1, x[2] - 1, 3) for x in surface_shapes]

coeffs_aoa = [(0.535, 0.091)]
coeffs_cd = [(0.00695, 1.297e-4, 1.466e-4)]

submodel = VLMSolverModel(
    surface_names=surface_names,
    surface_shapes=surface_shapes,
    num_nodes=num_nodes,
    free_stream_velocities=free_stream_velocities,
    eval_pts_location=0.25,
    # The location of the evaluation point is on the quarter-chord,
    # if this is not provided, it is defaulted to be 0.25.
    eval_pts_shapes=eval_pts_shapes,
    coeffs_aoa=coeffs_aoa,
    coeffs_cd=coeffs_cd,
    solve_option='optimization')
# a = model_1.declare_variable('a', val=1)
# model_1.register_output('dummy_obj', a + 0)

model_1.declare_variable(surface_names[0] + '_D', shape=(num_nodes, 1))

model_1.add(submodel, 'VLMSolverModel')
model_1.add_constraint('residual', equals=0)
model_1.add_constraint('wing_C_L', equals=0.5)

model_1.add_design_variable('gamma_b')
model_1.add_design_variable('twist_cp', upper=100, lower=-100)
model_1.add_objective(surface_names[0] + '_D')

sim = csdl_lite.Simulator(model_1)

sim.run()
# sim.prob.driver = om.pyOptSparseDriver()

# sim.prob.driver.options["optimizer"] = "SNOPT"

# driver = sim.prob.driver

# driver.options["optimizer"] = "SNOPT"
# driver.opt_settings["Verify level"] = 0

# driver.opt_settings["Major iterations limit"] = 100
# driver.opt_settings["Minor iterations limit"] = 100000
# driver.opt_settings["Iterations limit"] = 100000000
# driver.opt_settings["Major step limit"] = 2.0

# driver.opt_settings["Major feasibility tolerance"] = 1.0e-5
# driver.opt_settings["Major optimality tolerance"] = 6.0e-6

# sim.prob.run_driver()

####################################################################
# Print VLM outputs
####################################################################

# for i in range(len(surface_names)):
#     L_panel_name = surface_names[i] + '_L_panel'
#     D_panel_name = surface_names[i] + '_D_panel'
#     L_name = surface_names[i] + '_L'
#     D_name = surface_names[i] + '_D'
#     D_total_name = surface_names[i] + '_D_total'
#     CL_name = surface_names[i] + '_C_L'
#     CD_name = surface_names[i] + '_C_D_i'
#     print('lift\n', L_name, sim.prob[L_name])
#     print('drag\n', D_name, sim.prob[D_name])
#     print('total drag\n', D_total_name, sim.prob[D_total_name])
#     # print(
#     #     'L_panel',
#     #     L_panel_name,
#     #     sim.prob[L_panel_name].shape,
#     #     sim.prob[L_panel_name],
#     # )
#     # print(
#     #     'D_panel',
#     #     D_panel_name,
#     #     sim.prob[D_panel_name].shape,
#     #     sim.prob[D_panel_name],
#     # )
#     print('cl\n', CL_name, sim.prob[CL_name])
#     print('cd\n', CD_name, sim.prob[CD_name])

print('running check_partials\n=========================')
# sim.check_partials(compact_print=True)
# sim.prob.check_totals(
#     of='wing_D',
#     wrt='wing_bd_vtx_coords',
#     compact_print=True,
# )
# sim.compute_totals(
#     of='wing_D',
#     wrt='wing_bd_vtx_coords',
# )
sim.compute_totals(of='wing_eval_total_vel', wrt='wing_D')

# sim.compute_totals(
#     of='wing_eval_total_vel',
#     wrt='wing_bd_vtx_coords',
# )

sim.compute_totals(
    of='wing_C_L',
    wrt='wing_gamma_b',
)

# sim.prob.check_totals(
#     of='wing_C_L',
#     wrt='twist_cp',
#     compact_print=False,
# )

# b = sim.check_partials(compact_print=False, out_stream=None)
# sim.assert_check_partials(b, 5e-3, 1e-5)

# ####################################################################
# # Visualize n2 diagram (line 188)
# ####################################################################

# # sim.visualize_implementation()
# # res = np.einsum('ijk,ik->ij', sim['MTX'], sim['gamma_b']) + sim['b']
# # norm = np.linalg.norm(res)
# sim.prob.compute_totals()

# # importing numpy package
# import numpy as np

# # importing matplotlib package
# import matplotlib.pyplot as plt

# # importing mplot3d from
# # mpl_toolkits
# from mpl_toolkits import mplot3d

# # creating an empty canvas
# fig = plt.figure()

# # defining the axes with the projection
# # as 3D so as to plot 3D graphs
# ax = plt.axes(projection="3d")

# # creating a wide range of points x,y,z
# x = sim['in_mesh'][:, :, 0].flatten()
# y = sim['in_mesh'][:, :, 1].flatten()
# z = sim['in_mesh'][:, :, 2].flatten()

# # plotting a 3D line graph with X-coordinate,
# # Y-coordinate and Z-coordinate respectively
# ax.plot3D(x, y, z, 'red')

# ax.scatter3D(x, y, z, c=z, cmap='cividis')
# plt.savefig('org_mesh.png')

# # Showing the above plot
# plt.show()

# fig = plt.figure()

# # defining the axes with the projection
# # as 3D so as to plot 3D graphs
# ax = plt.axes(projection="3d")

# # creating a wide range of points x,y,z
# x = sim['mesh'][:, :, 0].flatten()
# y = sim['mesh'][:, :, 1].flatten()
# z = sim['mesh'][:, :, 2].flatten()

# # plotting a 3D line graph with X-coordinate,
# # Y-coordinate and Z-coordinate respectively
# ax.plot3D(x, y, z, 'red')

# ax.scatter3D(x, y, z, c=z, cmap='cividis')

# ##########################
# X = x
# Y = y
# Z = z
# max_range = np.array([X.max() - X.min(),
#                       Y.max() - Y.min(),
#                       Z.max() - Z.min()]).max() / 2.0

# mid_x = (X.max() + X.min()) * 0.5

# mid_y = (Y.max() + Y.min()) * 0.5

# mid_z = (Z.max() + Z.min()) * 0.5

# ax.set_xlim(mid_x - max_range, mid_x + max_range)

# ax.set_ylim(mid_y - max_range, mid_y + max_range)

# ax.set_zlim(mid_z - max_range, mid_z + max_range)

# plt.savefig('org_mesh.png')

# # Showing the above plot
# plt.show()
